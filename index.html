<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>Duel Layout – オンライン同期版</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
<style>
  :root{
    --card-h: 56px;
    --card-w: 40px;
    --gap: 6px;
    --font: 12px;
    --bar-h: 44px;
    --small-zone-w-mul: 1.4;
    --gate-w-mul: 1.2;
  }
  *, *::before, *::after { box-sizing: border-box; }
  .zone, .drop-gate { min-width: 0; }

  html,body{margin:0;height:100%;background:#1a1a1a;color:#fff;font-family:sans-serif;overflow:hidden}
  #app{height:100vh;display:flex;flex-direction:column}

  .bar{height:var(--bar-h);min-height:var(--bar-h);max-height:var(--bar-h);
       padding:0 var(--gap);display:flex;align-items:center;gap:var(--gap);border-bottom:1px solid #444}
  button,label.btn-like{
    background:#555;color:#fff;border:none;padding:6px 8px;border-radius:6px;font-size:calc(var(--font) * 0.95);cursor:pointer
  }
  button:active,label.btn-like:active{transform:translateY(1px)}
  button.danger{ background:#8b2e2e; }
  .spacer{flex:1}

  .field{flex:1;display:flex;flex-direction:column;border-bottom:1px solid #444;
         padding:var(--gap);gap:var(--gap);position:relative;background-size:cover;background-position:center}
  .row{display:flex;gap:var(--gap);min-height:0}

  .column{display:flex;flex-direction:column;gap:var(--gap);}
  .vstack-sm{display:flex;flex-direction:column;gap:var(--gap);align-items:stretch;}

  .zone{
    flex:1;
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.15);
    border-radius:10px;
    padding:var(--gap);
    display:flex;
    flex-direction:column;
    transition:border-color .12s ease, box-shadow .12s ease;
  }
  .zone.small{flex:none;width:calc(var(--card-w) * var(--small-zone-w-mul))}
  .zone-title{font-size:calc(var(--font) * 0.9);opacity:.8;margin-bottom:calc(var(--gap) * 0.6);line-height:1}

  .card-list{
    display:flex;
    flex-wrap:nowrap;                /* ← 横一列 */
    gap:calc(var(--gap) * 0.6);
    overflow-x:auto;                 /* ← 横スクロール */
    overflow-y:hidden;
    -webkit-overflow-scrolling:touch;
  }
  .slot5{display:grid;grid-template-columns:repeat(5, var(--card-w));gap:calc(var(--gap) * 0.6)}

  .zone.drop-ok, .drop-gate.drop-ok{border-color:#73d2ff; box-shadow:0 0 0 2px #73d2ff55 inset}
/* ドロップ先カードの可視化 */
.card.drop-target{ outline-color:#73d2ff; box-shadow:0 0 0 2px #73d2ff55 inset; }
  .card{
    position:relative;
    width:var(--card-w); height:var(--card-h);
    border-radius:8px;background:#2a2a2a;color:#111;
    display:flex;align-items:center;justify-content:center;font-weight:bold;user-select:none;
    outline:2px solid transparent;transition:transform .1s ease, outline-color .1s ease;
    font-size:calc(var(--font) * 0.95); overflow:hidden;
  }
  .card.tapped{transform:rotate(90deg)}
  .card.selected{outline-color:#73d2ff}
  .card-img{position:absolute; inset:0; width:100%; height:100%; object-fit:cover}

  /* 相手側は向き反転（通常=180°, タップ時=270°） */
  .opp .card{transform:rotate(180deg)}
  .opp .card.tapped{transform:rotate(270deg)}

  .drag-ghost{
    position:fixed; left:0; top:0; width:var(--card-w); height:var(--card-h); pointer-events:none;
    transform:translate(var(--x), var(--y));
    border-radius:8px; background:#222; color:#111; display:flex; align-items:center; justify-content:center;
    opacity:.98; z-index:10000; box-shadow:0 8px 24px rgba(0,0,0,.45);
    font-size:calc(var(--font) * 0.95); overflow:hidden;
  }
  .drag-ghost img{position:absolute; inset:0; width:100%; height:100%; object-fit:cover}
/* === stack (重ね表示) === */
  .stack{ position:relative; width:var(--card-w); height:var(--card-h); }
  .stack .card{ position:absolute; left:0; top:0; }
  /* 根本カードは(0,0)、2枚目以降は少しずつずらす */
  .stack .card:not(:first-child){ }
  .stack-badge{
    position:absolute; right:2px; bottom:2px;
    background:rgba(0,0,0,.55);
    border:1px solid rgba(255,255,255,.25);
    padding:2px 4px; border-radius:10px; font-size:10px; line-height:1;
  }
  .drop-gate{
    flex:none;
    width:calc(var(--card-w) * var(--gate-w-mul));
    background:rgba(255,255,255,0.05);
    border:1px dashed rgba(255,255,255,0.25);
    border-radius:6px;
    display:flex; align-items:center; justify-content:center;
    font-size:calc(var(--font)*0.8); opacity:0.9;
  }

  .overlay{position:fixed;inset:0;background:rgba(0,0,0,0.8);
           display:flex;justify-content:center;align-items:center;z-index:2000}
  .modal{background:#222;padding:16px;border-radius:8px;max-width:90vw;max-height:90vh;overflow:auto}
  .modal h3{margin:0 0 8px 0;font-size:14px}
  .deck-grid{display:grid;grid-template-columns:repeat(5, var(--card-w));grid-auto-rows:var(--card-h);gap:6px;justify-content:center}
  input[type="file"]{display:none}

  /* 行ごと水平スクロール可 & ゾーン高さ抑制 */
  .row{ overflow-x:auto; }
  .zone{ min-height:0; }
  .zone .slot5{ overflow:visible; }
  .zone.hand .card-list{max-height:calc(var(--card-h)*2 + var(--gap)*1.2)}
  .zone.battle .card-list,
  .zone.mana .card-list{max-height:calc(var(--card-h)*2 + var(--gap)*2)}
  /* フィールド全体にだけ縦スクロールを許可（見切れ時に逃がす） */
.field{ overflow-y:auto; }

/* 自分側フィールドで手札ゾーンを下部に張り付け（常時可視） */
.field:not(.opp) .zone.hand{
  position: sticky;
  bottom: 0;
  z-index: 1400;
  background: rgba(0,0,0,.35);
  backdrop-filter: saturate(120%) blur(2px);
}
/* === 操作ドロワー & FAB（バーは初期非表示） === */
.bar{ display:none !important; } /* 旧バーは隠す（残しておくが表示しない） */

.fab{
  position:fixed; right:12px; bottom:16px; z-index:2600;
  width:52px; height:52px; border-radius:999px; font-size:12px;
  display:flex; align-items:center; justify-content:center;
  background:#2e6; color:#111; font-weight:700; box-shadow:0 6px 16px rgba(0,0,0,.35);
}

.edge-hotzone{
  position:fixed; left:0; top:0; bottom:0; width:14px; z-index:2600;
  touch-action:none; /* 水平方向のスワイプを確実に取る */
}

.drawer{
  position:fixed; inset:0; z-index:2550; pointer-events:none;
}
.drawer.open{ pointer-events:auto; }
.drawer::before{
  content:""; position:absolute; inset:0; background:rgba(0,0,0,.45);
  opacity:0; transition:opacity .18s ease;
}
.drawer.open::before{ opacity:1; }

.drawer-panel{
  position:absolute; left:0; top:0; bottom:0; width:min(78vw,360px);
  background:#1c1c1c; border-right:1px solid #333;
  transform:translateX(-100%); transition:transform .18s ease;
  display:flex; flex-direction:column; padding:10px; gap:8px;
}
.drawer.open .drawer-panel{ transform:translateX(0); }

.drawer-header{
  display:flex; align-items:center; justify-content:space-between;
  padding:2px 2px 8px; border-bottom:1px solid #333; font-size:12px; opacity:.9;
}
.drawer-content{ display:grid; grid-template-columns:1fr 1fr; gap:8px; padding-top:10px; }
.drawer-content button{ width:100%; }
.drawer-content label.btn-like{ width:100%; text-align:center; }
</style>
</head>
<body>
<div id="app"></div>

<script>
(() => {
  const { createApp } = Vue;

  // ===== WebSocket設定 =====
  const WS_URL = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws';
  const ROOM   = "room1";
  // 端末ID（UUID）を永続化
const DEVICE_KEY = 'dm_device_id';
let deviceId = localStorage.getItem(DEVICE_KEY);
if (!deviceId) {
  deviceId = (self.crypto?.randomUUID?.()
    ? self.crypto.randomUUID()
    : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
        const r = Math.random()*16|0, v = c==='x'?r:(r&0x3|0x8);
        return v.toString(16);
      })
  );
  localStorage.setItem(DEVICE_KEY, deviceId);
}

  createApp({
    data(){
      const makeDeck = (prefix) =>
        Array.from({ length: 40 }, (_, i) => ({
          id: `${prefix}-c${i + 1}`,
          num: i + 1,
          image: null
        }));

      return {
        // 役割・接続
        me: -1,
        ws: null,
        myIndex: 1,       // 0 or 1
        isSpectator: false,
        role: -1,
        gotStateOnce: false,
        initTimer: null,

        // 盤面
        players: [
          { name: "プレイヤー2", zones: { hand:[], mana:[], graveyard:[], shield:[], deck:makeDeck("p0"), battle:[] }, sleeve: null, mat: null },
          { name: "プレイヤー1", zones: { hand:[], mana:[], graveyard:[], shield:[], deck:makeDeck("p1"), battle:[] }, sleeve: null, mat: null }
        ],
        cardStates: {},

        // UI
        selected: null,
        lpTimer: null,
        drag: { active:false, pIndex:null, zoneKey:null, card:null, x:0, y:0, startX:0, startY:0, moved:false, dropTarget:null },
        zoneKeys: ["hand","mana","graveyard","shield","deck","battle","top","bottom"],
        modal: { show:false, cards:[], title:'', faceMode:'face' },

        // チャット
        chatOpen:false,
        chatMsg:"",
        chatLog:[]
        , uiScale: 1.0
        , drawer: { open: false }, gesture: { startX: 0, tracking: false }
      }
    },

    computed:{
      viewMyIndex(){ return this.isSpectator ? 1 : this.myIndex; },
      viewOppIndex(){ return 1 - this.viewMyIndex; },
      dragGhostStyle(){
        const w = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-w')) || 40;
        const h = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-h')) || 56;
        return {'--x': (this.drag.x - w/2) + 'px','--y': (this.drag.y - h/2) + 'px'};
      }
    },

    mounted(){
      // 接続
      this.ws = new WebSocket(WS_URL);

      this.ws.addEventListener("open", () => {
        console.log("WS connected");
     this.ws.send(JSON.stringify({ type: "join", room: ROOM, deviceId }));
        this.ws.send(JSON.stringify({ type: "request_state", room: ROOM }));
      });

      // messageは1本化
      this.ws.addEventListener("message", (ev) => {
        let msg; try { msg = JSON.parse(ev.data); } catch { return; }

        // 役割
        if (msg.type === "role" && typeof msg.index === "number") {
          const idx = msg.index;
          this.me = idx;
          this.role = idx;
          if (idx === 0 || idx === 1) { this.myIndex = idx; this.isSpectator = false; }
          else { this.myIndex = 1; this.isSpectator = true; }
        }

        // 盤面同期（配列/オブジェクト両対応）
        if (msg.type === "syncState" && msg.state) {
          this.gotStateOnce = true;
          if (this.initTimer) { clearTimeout(this.initTimer); this.initTimer = null; }
          if (Array.isArray(msg.state)) {
            this.players = JSON.parse(JSON.stringify(msg.state));
          } else {
            if (msg.state.players) this.players = JSON.parse(JSON.stringify(msg.state.players));
            if (msg.state.cardStates) this.cardStates = JSON.parse(JSON.stringify(msg.state.cardStates));
          }
        }

        // 誰かから request_state が来たら返す（保険）
        if (msg.type === "request_state") {
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({
              type: "syncState", room: ROOM,
              state: { players: this.players, cardStates: this.cardStates || {} }
            }));
          }
        }

        // チャット
        if (msg.type === "chat" && msg.text) {
          this.chatLog.push({
            id: crypto.randomUUID?.() || (Date.now() + Math.random()),
            from: msg.from ?? "相手",
            text: msg.text,
            time: msg.time ?? ""
          });
          this.$nextTick(() => {
            const pane = document.getElementById("chat-pane");
            if (pane) pane.scrollTop = pane.scrollHeight;
          });
        }
      });

      // 最初に誰も配ってなければ自分が配って送る
      this.initTimer = setTimeout(() => {
        if (!this.gotStateOnce) {
          this.setupLocal(0, { shuffle:true });
          this.setupLocal(1, { shuffle:true });
          this.sendFullState();
        }
      }, 400);
const savedScale = parseFloat(localStorage.getItem('uiScale') || '1');
if (!isNaN(savedScale)) this.uiScale = Math.max(0.8, Math.min(savedScale, 1.4));
      // レイアウトと入力
      const resize = () => this.computeLayout();
      window.addEventListener('resize', resize);
      window.addEventListener('orientationchange', resize);
      this.computeLayout();
      window.addEventListener('pointermove', this.onPointerMove);
      window.addEventListener('pointerup', this.onPointerUp);
    },

    beforeUnmount(){
      window.removeEventListener('pointermove', this.onPointerMove);
      window.removeEventListener('pointerup', this.onPointerUp);
    },

    methods:{
      /* === 権限 === */
      canInteract(pIndex){ if (this.isSpectator) return false; return pIndex === this.viewMyIndex; },

      /* === レイアウト === */
      computeLayout(){
        const vh = window.innerHeight, vw = window.innerWidth, barH = 0;
        const rows = 5, titlePad = 12;
        const styles = getComputedStyle(document.documentElement);
        const gap = parseFloat(styles.getPropertyValue('--gap')) || 6;
        const smallMul = parseFloat(styles.getPropertyValue('--small-zone-w-mul')) || 1.4;
        const gateMul  = parseFloat(styles.getPropertyValue('--gate-w-mul')) || 1.2;

        const usableH = Math.max(200, vh - barH);
        let hCard = Math.floor((usableH - rows * (titlePad + gap)) / rows);
        hCard = Math.max(34, Math.min(hCard, 120));
        let wCard = Math.floor(hCard * 0.714);

        const gaps = 4 * gap, safety = 24;
        const neededW = ((2*smallMul + 2*gateMul + 5) * wCard) + gaps + safety;

        const scaleW = neededW > vw ? (vw / neededW) : 1;
        wCard = Math.floor(wCard * scaleW * (this.uiScale || 1));
hCard = Math.floor(hCard * scaleW * (this.uiScale || 1));

        document.documentElement.style.setProperty('--card-h', hCard + 'px');
        document.documentElement.style.setProperty('--card-w', wCard + 'px');
      },

      /* === コイントス（任意） === */
      coinToss(){
        const first = Math.random() < 0.5;
        const text  = `コイントス結果：${first ? '先行' : '後攻'}`;
        this.chatLog.push({ id:crypto.randomUUID?.()||(Date.now()+Math.random()), from:'System', text, time:new Date().toLocaleTimeString() });
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify({ type:'chat', room:ROOM, text, from:'System', time:new Date().toLocaleTimeString() }));
        }
      },

      /* === 同期 === */
      syncNow(){ // 受信
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
        this.ws.send(JSON.stringify({ type: "request_state", room: ROOM }));
      },
      sendFullState(){ // 送信
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
        this.ws.send(JSON.stringify({
          type: "syncState", room: ROOM,
          state: { players: this.players, cardStates: this.cardStates || {} }
        }));
      },
      // 互換（昔の @click="sendState" を生かす）
      sendState(){ this.sendFullState(); },

      /* === 山札・配り === */
      setupLocal(pIndex, opts = { shuffle: false }) {
  // 40枚の空スロットだけ用意（画像なし・背面）
  const deck = this.players[pIndex].zones.deck;
  const makeEmpty = () => ({
    id: (self.crypto?.randomUUID?.() ? crypto.randomUUID() : (Date.now() + '' + Math.random())),
    num: deck.length + 1,
    image: null
  });
  while (deck.length < 40) deck.push(makeEmpty());
  if (deck.length > 40) deck.length = 40;
  this.$forceUpdate();
},
      drawCard(pIndex){
        if (!this.canInteract(pIndex)) return;
        const P = this.players[pIndex];
        if(!P.zones.deck.length) return;
        P.zones.hand.push(P.zones.deck.shift());
        this.$forceUpdate(); 
      },
      shuffleDeck(p){
        const d = this.players[p].zones.deck;
        for(let i=d.length-1;i>0;i--){
          const j=Math.floor(Math.random()*(i+1));
          [d[i],d[j]]=[d[j],d[i]];
        }
      },
      shuffleDeckZone(pIndex){
        const deck = this.players[pIndex]?.zones?.deck;
        if (!Array.isArray(deck) || deck.length < 2) return;
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        this.$forceUpdate(); 
      },
/* === 盤面クリア（自分側のみ） ===
   wipeImages=true ならデッキ画像・スリーブ・マットも撤去 */
resetBoard(pIndex, wipeImages = true){
  const P = this.players[pIndex];
  // 全ゾーンを空に（デッキは長さ維持だが画像を消す）
  const zones = ["hand","shield","battle","mana","graveyard"];
  for(const z of zones){ P.zones[z].splice(0); }

  if (wipeImages){
    for (const c of P.zones.deck){ c.image = null; }
    P.sleeve = null; P.mat = null;
  }

  // 自分のカード状態もリセット
  for (const id of Object.keys(this.cardStates)){
    if (this.ownerOf(id) === pIndex) delete this.cardStates[id];
  }
  this.$forceUpdate();
},

/* === 退室：片付け→同期→サーバへ通知→切断→観戦モードに移行（ローカル） === */
exitRoom(){
  const p = this.viewMyIndex;
  const ok = confirm("退室します。自分の盤面を初期化して全員へ同期した後、切断します。よろしいですか？");
  if (!ok) return;

  // 1) 盤面初期化（デッキ画像・スリーブ等も撤去）
  this.resetBoard(p, true);

  // 2) 全員へ同期（自分の片付けを反映）
  this.sendFullState();

  // 3) サーバに任意通知（実装なくても無害）
  try { this.ws?.send(JSON.stringify({ type:"leave", room: ROOM, deviceId })); } catch {}

  // 4) 切断
  try { this.ws?.close(); } catch {}

  // 5) ローカル状態を観戦へ
  this.me = -1; this.role = -1; this.isSpectator = true;
  this.chatLog.push({
    id: crypto.randomUUID?.() || (Date.now()+Math.random()),
    from: "System",
    text: "退室しました（再接続するにはページを再読み込み）",
    time: new Date().toLocaleTimeString()
  });
},
     moveCard(pIndex, from, to, cardId){
        if (!this.canInteract(pIndex)) return;
        const P = this.players[pIndex];
        const src = P.zones[from]; if(!Array.isArray(src)) return;

        // 元ゾーンから対象カードを取り出す
        const idx = src.findIndex(c => c.id === cardId); if(idx<0) return;
        const card = src.splice(idx,1)[0];

        // fromがbattleで、cardがスタックの根（=stackHost無し）なら子もまとめて移動
        const isRoot = !(this.cardStates[card.id]?.stackHost);
        let children = [];
        if (from === 'battle' && isRoot){
          const allKids = this.stackChildren(card.id);
          for (const kid of allKids){
            const kidx = src.findIndex(c => c.id === kid.id);
            if (kidx >= 0) children.push(src.splice(kidx,1)[0]);
          }
        }

        // 山上/山下の特別処理
        if(to === "top"){ P.zones.deck.unshift(card); for(const k of children) P.zones.deck.unshift(k); }
        else if(to === "bottom"){ P.zones.deck.push(card); for(const k of children) P.zones.deck.push(k); }
        else {
          const dst = P.zones[to]; if(Array.isArray(dst)){
            dst.push(card);
            for(const k of children) dst.push(k);
          }
        }

        // 戦場→他ゾーンに出た場合はスタック関係を解除（他ゾーンは平置き）
        if (to !== 'battle'){
          if (this.cardStates[card.id]?.stackHost) delete this.cardStates[card.id].stackHost;
          for (const k of children){
            if (this.cardStates[k.id]?.stackHost) delete this.cardStates[k.id].stackHost;
          }
        }

        this.$forceUpdate();
      },

      toggleTap(card){
        if (!card || !card.id) return;
        const st = this.mergeCardState(card.id, {});  // 既存保持
        st.tapped = !st.tapped;                       // 必要なキーだけ更新
        this.$forceUpdate(); this.sendState?.();
      },
      flip(card){
        if (!this.canInteract(this.ownerOf(card.id))) return;
        const st = this.cardStates[card.id] ||= { tapped:false, faceDown:false };
        st.faceDown = !st.faceDown;
        this.$forceUpdate(); 
      },

      onImportDeck(evt, pIndex){
        if (!this.canInteract(pIndex)) { evt.target.value=''; return; }
        const file = evt.target.files?.[0]; if(!file) return;
        const reader = new FileReader();
        reader.onload = (e)=>{
          try{
            const deckJson = JSON.parse(e.target.result);
            this.players[pIndex].sleeve = deckJson.sleeve || null;
            this.players[pIndex].mat    = deckJson.mat || null; // 相手にも適用可
            this.applyDeckImages(pIndex, deckJson);
          }catch(err){ console.error(err); alert("デッキJSONの読み込みに失敗しました"); }
          evt.target.value = '';
        };
        reader.readAsText(file);
      },
      applyDeckImages(pIndex, deckJson){
  const imgs = Array.isArray(deckJson?.images) ? deckJson.images : [];
  const P = this.players[pIndex];
  const deck = P.zones.deck;

  // 常に空40を確保（不足を補う）
  while (deck.length < 40) {
    deck.push({ id: (self.crypto?.randomUUID?.() ? crypto.randomUUID() : (Date.now()+''+Math.random())), num: deck.length+1, image: null });
  }
  if (deck.length > 40) deck.length = 40;

  // デッキ先頭から画像を当てる（他ゾーンは触らない）
  const n = Math.min(deck.length, imgs.length);
  for (let i=0;i<n;i++){
    const url = imgs[i];
    deck[i].image = (typeof url === 'string' && url) ? url : null;
  }
  for (let i=n;i<deck.length;i++){
    // 足りない分は空のまま
    if (!deck[i].image) deck[i].image = null;
  }

  // 盤面が“まっさら”なら自動でシャッフル→シールド5→手札5
  const isPristine =
    P.zones.hand.length===0 &&
    P.zones.shield.length===0 &&
    P.zones.battle.length===0 &&
    P.zones.mana.length===0 &&
    P.zones.graveyard.length===0;

  const enough = deck.filter(c=>!!c.image).length >= 10; // 初期配りに必要最低限
  if (isPristine && enough) {
    // シャッフル（既存の関数名に合わせて呼び出し）
    this.shuffleDeckZone(pIndex);

    // deal: シールド5（伏せ）→手札5（表）
    const take = k => Array.from({length: Math.min(k, P.zones.deck.length)}, _ => P.zones.deck.shift());
    const ss = take(5), hh = take(5);
    P.zones.shield.push(...ss);
    P.zones.hand.push(...hh);
    for (const c of ss) {
      const st = this.cardStates[c.id] ||= { tapped:false, faceDown:false };
      st.faceDown = true;
    }
  }

  this.$forceUpdate();
  this.sendState?.(); // 同期（観戦含む全員へ）
},

      /* === 表示ユーティリティ === */
      isFaceDown(card){ const st = this.cardStates[card.id]; return !!(st && st.faceDown); },
      isTapped(card){ const st = this.cardStates[card.id]; return !!(st && st.tapped); },
      cardClass(card){ return { 'tapped': this.isTapped(card), 'selected': this.selected && this.selected.card.id===card.id }; },
      cardFaceImage(pIndex, card){ return this.isFaceDown(card) ? (this.players[pIndex].sleeve || null) : (card.image || null); },
      deckTopBackImage(pIndex){ return this.players[pIndex].sleeve || null; },
      zoneId(pIndex, zoneKey){ return `zone-${pIndex}-${zoneKey}`; },
      ownerOf(cardId) {
  // 盤面上の“実際の所在”からオーナーを決定（UUIDでもOK）
  for (let p = 0; p < 2; p++) {
    const Z = this.players[p].zones;
    for (const k of ["hand", "mana", "graveyard", "shield", "deck", "battle"]) {
      const a = Z[k];
      if (Array.isArray(a) && a.some(c => c.id === cardId)) return p;
    }
  }
  // 最後の保険（旧ID互換）
  return cardId.startsWith('p0-') ? 0 : 1;
},
// --- 追加: state安全更新ヘルパー（stackHost等を保持して部分更新） ---
mergeCardState(cardId, patch) {
  const st = this.cardStates[cardId] ||= { tapped: false, faceDown: false };
  Object.assign(st, patch);
  return st;
},
      /* === スタック（重ね） === */
      // ルート＝stackHostを持たない戦場カード
      battleRoots(pIndex){
        const list = this.players[pIndex].zones.battle;
        return list.filter(c => !(this.cardStates[c.id]?.stackHost));
      },
      // ホストidにぶら下がる子カード一覧（同じ所有者の戦場から探索）
      // ホストチェーンを遡って“最上位の親”を返す（ネスト解消の要）
rootHostId(cardId) {
    let h = cardId;
    const seen = new Set();
    while (this.cardStates[h]?.stackHost) {
      if (seen.has(h)) break; // 保険：循環防止
      seen.add(h);
      h = this.cardStates[h].stackHost;
    }
    return h;
  },
  
  // ホストid直下だけでなく、“最上位の親が hostId” のすべての子を集める（フラット表示）
  stackChildren(hostId) {
    const owner = this.ownerOf(hostId);
    const list = this.players[owner].zones.battle;
    return list.filter(c => {
      const st = this.cardStates[c.id];
      if (!st || !st.stackHost) return false;
      return this.rootHostId(c.id) === hostId; // ← ルート一致で集約
    });
  },
      // カードをホストへ重ねる（同一プレイヤー＆同一ゾーン前提）
      stackCards(hostId, childId) {
  if (hostId === childId) return;
  if (this.ownerOf(hostId) !== this.ownerOf(childId)) return;
  
  // つねに“最上位の親”へ重ねる（多段化させない）
  const root = this.rootHostId(hostId);
  
  const st = this.cardStates[childId] ||= { tapped: false, faceDown: false };
  st.stackHost = root;
  
  this.$forceUpdate();
  this.sendState?.();
},
      // 子カードをスタックから外す
      unstack(cardId){
        const st = this.cardStates[cardId];
        if (st && 'stackHost' in st) { delete st.stackHost; }
        this.$forceUpdate(); this.sendState?.();
      },
      // ポインタ位置直下の .card[data-id] を同ゾーンから特定（除外IDは除く）
      findCardUnderPointerId(pIndex, zoneKey, px, py, excludeId){
  const rootEl = document.getElementById(this.zoneId(pIndex, zoneKey));
  if (!rootEl) return null;

  const list = (document.elementsFromPoint && document.elementsFromPoint(px, py))
               || [document.elementFromPoint(px, py)];
  for (const el of list){
    if (!el) continue;
    if (!rootEl.contains(el)) continue;
    if (!el.classList || !el.classList.contains('card')) continue;
    const cid = el.getAttribute('data-id');
    if (cid && cid !== excludeId) return cid;   // 最前面のカードを採用
  }
  return null;
},

      /* === 入力 === */
      pointerDownCard(e, pIndex, zoneKey, card){
        if (!this.canInteract(pIndex)) return;
        e.preventDefault();
        const isDeck = zoneKey === 'deck';
        if(!isDeck){
          this.lpTimer = setTimeout(() => { this.flip(card); this.lpTimer = null; }, 450);
        }
        this.drag.active = true; this.drag.pIndex = pIndex; this.drag.zoneKey = zoneKey; this.drag.card = card;
        this.drag.startX = e.clientX; this.drag.startY = e.clientY; this.drag.x = e.clientX; this.drag.y = e.clientY;
        this.drag.moved = false; this.drag.dropTarget = null;
        this.selected = { pIndex, zoneKey, card };
      },
      onPointerMove(e){
  if(!this.drag.active) return;
  this.drag.x = e.clientX; this.drag.y = e.clientY;

  if(!this.drag.moved){
    const dx = this.drag.x - this.drag.startX, dy = this.drag.y - this.drag.startY;
    if(Math.hypot(dx,dy) > 6){
      // ← ここで初めてドラッグ開始と確定
      this.drag.moved = true;
      if(this.lpTimer){ clearTimeout(this.lpTimer); this.lpTimer = null; }

      // ★ 剥がしは“ドラッグ開始が確定した瞬間”にだけ行う
      const stDrag = this.cardStates[this.drag.card.id];
      if (stDrag && stDrag.stackHost) {
        this.unstack(this.drag.card.id);
      }
    }
  }

  if(this.drag.moved){
    this.updateDropTarget(e.clientX, e.clientY);
  }
},
      onPointerUp(){
  if (!this.drag.active) return;

  // タップ（長押し）処理
  if (this.drag.zoneKey !== 'deck' && this.lpTimer){
    clearTimeout(this.lpTimer); this.lpTimer = null;
    this.toggleTap(this.drag.card);
  }

  const tgt = this.drag.dropTarget;

  // ドラッグ移動が発生し、かつドロップ先が判定できている場合のみ処理
  if (this.drag.moved && tgt){
    // 戦場 → 戦場の“カード上”ならスタック
    if (tgt.zoneKey === 'battle'){
    const baseId = this.findCardUnderPointerId(
  this.drag.pIndex, 'battle', this.drag.x, this.drag.y, this.drag.card?.id
);
const hostId = baseId ? this.rootHostId(baseId) : null; // ← ルートへ矯正
      if (hostId){
        this.stackCards(hostId, this.drag.card.id);
        this.clearDrag();
        return;
      }
    }
    // それ以外は通常移動
    this.moveCard(this.drag.pIndex, this.drag.zoneKey, tgt.zoneKey, this.drag.card.id);
  }

  this.clearDrag();
},
      clearDrag(){
        document.querySelectorAll('.zone.drop-ok,.drop-gate.drop-ok,.card.drop-target')
  .forEach(el => el.classList.remove('drop-ok', 'drop-target'));
        this.drag = { active:false, pIndex:null, zoneKey:null, card:null, x:0, y:0, startX:0, startY:0, moved:false, dropTarget:null };
        this.selected = null;
      },
      updateDropTarget(px, py){
  const pid = this.drag.pIndex; let best = null;

  // 1) ゾーン判定（既存の行為：枠ハイライト）
  for(const key of this.zoneKeys){
    const el = document.getElementById(this.zoneId(pid, key)); if(!el) continue;
    const r = el.getBoundingClientRect();
    const inside = (px>=r.left && px<=r.right && py>=r.top && py<=r.bottom);
    el.classList.toggle('drop-ok', inside);
    if(inside) best = { pIndex:pid, zoneKey:key };
  }

  // 既存ハイライトの掃除
  document.querySelectorAll('.card.drop-target').forEach(el => el.classList.remove('drop-target'));

  // 直近のゾーン候補を保持
  this.drag.dropTarget = best;

  // 2) ドラッグ中にバトル内のカードへ触れたら即スタック
  if (this.drag.active && this.drag.moved && best && best.zoneKey === 'battle'){
    const baseId = this.findCardUnderPointerId(pid, 'battle', px, py, this.drag.card?.id);
const hostId = baseId ? this.rootHostId(baseId) : null; // ← ルートへ矯正
    if (hostId){
      // 視覚的にターゲットを一瞬ハイライト（任意）
      const zoneRoot = document.getElementById(this.zoneId(pid,'battle'));
      const el = zoneRoot?.querySelector(`.card[data-id="${hostId}"]`);
      if (el) el.classList.add('drop-target');

      // 即スタックしてドラッグ終了
      this.stackCards(hostId, this.drag.card.id);
      this.clearDrag();
      return;
    }
  }
},


      /* === モーダル / チャット === */
      openModal(cards, title, opts={}){ this.modal = { show:true, cards:[...cards], title, faceMode: opts.faceMode || 'face' }; },
      closeModal(){ this.modal.show = false; },
      modalImageSrc(card){ return (this.modal.faceMode === 'back') ? (this.players[this.ownerOf(card.id)].sleeve || null) : (card.image || null); },
      toggleChat(){ this.chatOpen = !this.chatOpen; },
      sendChat(){
        const text = (this.chatMsg || "").trim(); if (!text) return;
        const payload = { type:"chat", room:ROOM, text, from:`P${this.viewMyIndex+1}`, time:new Date().toLocaleTimeString() };
        if (this.ws && this.ws.readyState === WebSocket.OPEN) this.ws.send(JSON.stringify(payload));
        this.chatLog.push({ id:crypto.randomUUID?.() || (Date.now()+Math.random()), from:payload.from, text, time:payload.time });
        this.chatMsg = "";
        this.$nextTick(() => {
          const pane = document.getElementById("chat-pane");
          if (pane) pane.scrollTop = pane.scrollHeight;
        });
      }
      , toggleDrawer(){ this.drawer.open = !this.drawer.open; }
, openDrawer(){ this.drawer.open = true; }
, closeDrawer(){ this.drawer.open = false; }
, setScale(s) {
  this.uiScale = s;
  localStorage.setItem('uiScale', String(s));
  this.computeLayout();
  this.closeDrawer();
}
, edgeDown(e){
    this.gesture.tracking = true;
    this.gesture.startX = (e.clientX ?? (e.touches?.[0]?.clientX || 0));
  }
, edgeMove(e){
    if(!this.gesture.tracking) return;
    const x = (e.clientX ?? (e.touches?.[0]?.clientX || 0));
    if (x - this.gesture.startX > 22){ this.openDrawer(); this.gesture.tracking = false; }
  }
, edgeUp(){ this.gesture.tracking = false; }
    },

    template: `
  <div style="height:100%;display:flex;flex-direction:column;">
    <div class="bar">
      <button @click="syncNow">同期(受信)</button>
      <button @click="sendFullState">同期(送信)</button>
      <button @click="shuffleDeckZone(viewMyIndex)">山札シャッフル</button>
      <button @click="openModal(players[viewMyIndex].zones.deck,'自分の山札（5×8）',{ faceMode:'back' })">山札表示</button>
      <button @click="openModal(players[viewMyIndex].zones.graveyard,'自分の墓地（5×8）')">墓地表示</button>
      <button @click="openModal(players[viewOppIndex].zones.graveyard,'相手の墓地（5×8）')">相手の墓地</button>
      <button @click="drawCard(viewMyIndex)">ドロー</button>
      <button @click="coinToss">コイントス</button>
      <button @click="chatOpen=!chatOpen">{{ chatOpen ? 'チャット閉じる' : 'チャット開く' }}</button>
      <button class="danger" @click="exitRoom()">退室</button>
      <span class="spacer"></span>
      <label class="btn-like">
        デッキ読込
        <input type="file" accept="application/json" @change="onImportDeck($event, viewMyIndex)">
      </label>
    </div>
    <!-- FAB（操作一覧） -->
<button class="fab" @click="toggleDrawer">操作</button>

<!-- 左端スワイプ用ホットゾーン -->
<div class="edge-hotzone" @pointerdown="edgeDown" @pointermove="edgeMove" @pointerup="edgeUp"></div>

<!-- 操作ドロワー -->
<div class="drawer" :class="{open: drawer.open}" @click="closeDrawer">
  <div class="drawer-panel" @click.stop>
    <div class="drawer-header">
      <div>操作一覧</div>
      <button @click="closeDrawer">閉じる</button>
    </div>
    <div class="drawer-content">
      <button @click="syncNow()">同期(受信)</button>
      <button @click="sendFullState()">同期(送信)</button>
      <button @click="shuffleDeckZone(viewMyIndex)">山札シャッフル</button>
      <button @click="openModal(players[viewMyIndex].zones.deck,'自分の山札（5×8）',{ faceMode:'back' })">山札表示</button>
      <button @click="openModal(players[viewMyIndex].zones.graveyard,'自分の墓地（5×8）')">墓地表示</button>
      <button @click="openModal(players[viewOppIndex].zones.graveyard,'相手の墓地（5×8）')">相手の墓地</button>
      <button @click="drawCard(viewMyIndex)">ドロー</button>
      <button @click="coinToss()">コイントス</button>
      <!-- チャット開閉 -->
<button @click="toggleChat()">{{ chatOpen ? 'チャットを閉じる' : 'チャットを開く' }}</button>

<!-- デッキ読込（ファイル選択→読込→ドロワー閉じ） -->
<label class="btn-like">
  デッキ読込
  <input type="file" accept="application/json"
         @change="(e)=>{ onImportDeck(e, viewMyIndex); }">
</label>
      <button class="danger" @click="exitRoom()">退室</button>
    </div>
  </div>
</div>

    <!-- 相手フィールド（上段・反転表示） -->
    <section class="field opp"
             :style="{ backgroundImage: players[viewOppIndex].mat ? 'url(' + players[viewOppIndex].mat + ')' : 'none' }">
      <div class="row">
        <div class="zone small" :id="zoneId(viewOppIndex,'graveyard')">
          <div class="zone-title">墓地（{{ players[viewOppIndex].zones.graveyard.length }}）</div>
          <div class="card-list">
            <div v-if="players[viewOppIndex].zones.graveyard.length"
                 :key="players[viewOppIndex].zones.graveyard.at(-1).id"
                 class="card" :class="cardClass(players[viewOppIndex].zones.graveyard.at(-1))"
@pointerdown="openModal(players[viewOppIndex].zones.graveyard,'相手の墓地（5×8）')">
              <img v-if="cardFaceImage(viewOppIndex, players[viewOppIndex].zones.graveyard.at(-1))"
                   :src="cardFaceImage(viewOppIndex, players[viewOppIndex].zones.graveyard.at(-1))" class="card-img" alt="">
              <template v-else>G</template>
            </div>
          </div>
        </div>

        <div class="column" style="flex:1">
          <div class="zone" :id="zoneId(viewOppIndex,'hand')">
            <div class="zone-title">手札（相手）{{ players[viewOppIndex].zones.hand.length }}</div>
            <div class="card-list">
              <div v-for="c in players[viewOppIndex].zones.hand" :key="c.id" class="card" :class="cardClass(c)">
                <img v-if="players[viewOppIndex].sleeve" :src="players[viewOppIndex].sleeve" class="card-img" alt="">
                <template v-else>C</template>
              </div>
            </div>
          </div>

          <div class="zone" :id="zoneId(viewOppIndex,'mana')">
            <div class="zone-title">マナ（相手）</div>
            <div class="card-list">
              <div v-for="c in players[viewOppIndex].zones.mana" :key="c.id" class="card" :class="cardClass(c)">
                <img v-if="cardFaceImage(viewOppIndex,c)" :src="cardFaceImage(viewOppIndex,c)" class="card-img" alt="">
                <template v-else>M</template>
              </div>
            </div>
          </div>

          <div class="zone" :id="zoneId(viewOppIndex,'shield')">
            <div class="zone-title">シールド（相手）</div>
            <div class="slot5">
              <div v-for="c in players[viewOppIndex].zones.shield" :key="c.id" class="card" :class="cardClass(c)">
                <img v-if="cardFaceImage(viewOppIndex,c)" :src="cardFaceImage(viewOppIndex,c)" class="card-img" alt="">
                <template v-else>S</template>
              </div>
            </div>
          </div>
        </div>

        <div class="vstack-sm" style="align-self:flex-end">
          <div class="zone small" :id="zoneId(viewOppIndex,'deck')">
            <div class="zone-title">山札（{{ players[viewOppIndex].zones.deck.length }}）</div>
            <div class="card-list">
              <div v-if="players[viewOppIndex].zones.deck.length"
                   :key="players[viewOppIndex].zones.deck[0].id"
                   class="card" :class="cardClass(players[viewOppIndex].zones.deck[0])">
                <img v-if="deckTopBackImage(viewOppIndex)" :src="deckTopBackImage(viewOppIndex)" class="card-img" alt="">
                <template v-else>D</template>
              </div>
            </div>
          </div>
          <div class="drop-gate" :id="zoneId(viewOppIndex,'top')">山上</div>
          <div class="drop-gate" :id="zoneId(viewOppIndex,'bottom')">山下</div>
        </div>
      </div>

      <div class="row">
        <div class="zone" :id="zoneId(viewOppIndex,'battle')">
          <div class="zone-title">バトル（相手）</div>
          <div class="card-list">
        <div v-for="root in battleRoots(viewOppIndex)" :key="root.id" class="stack">
              <div class="card" :class="cardClass(root)" :data-id="root.id">
                <img v-if="cardFaceImage(viewOppIndex,root)" :src="cardFaceImage(viewOppIndex,root)" class="card-img" alt="">
                <template v-else>B</template>
              </div>
              <div v-for="(cc,i) in stackChildren(root.id)" :key="cc.id"
                   class="card" :class="cardClass(cc)"
                 :style="{ left: (i*8)+'px', top: (i*10)+'px' }"
                   :data-id="cc.id">
                <img v-if="cardFaceImage(viewOppIndex,cc)" :src="cardFaceImage(viewOppIndex,cc)" class="card-img" alt="">
              </div>
              <div v-if="stackChildren(root.id).length" class="stack-badge">{{ 1 + stackChildren(root.id).length }}</div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 自分フィールド（下段） -->
    <section class="field" :style="{ backgroundImage: players[viewMyIndex].mat ? 'url(' + players[viewMyIndex].mat + ')' : 'none' }">
      <div class="row">
        <div class="zone" :id="zoneId(viewMyIndex,'battle')">
          <div class="zone-title">バトル（自分）</div>
          <div class="card-list">
          <div v-for="root in battleRoots(viewMyIndex)" :key="root.id" class="stack">
              <div class="card" :class="cardClass(root)" :data-id="root.id"
                   @pointerdown="pointerDownCard($event,viewMyIndex,'battle',root)">
                <img v-if="cardFaceImage(viewMyIndex,root)" :src="cardFaceImage(viewMyIndex,root)" class="card-img" alt="">
                <template v-else>B</template>
              </div>
              <div v-for="(cc,i) in stackChildren(root.id)" :key="cc.id"
                   class="card" :class="cardClass(cc)"
                  :style="{ left: (i*8)+'px', top: (i*10)+'px' }"
                   :data-id="cc.id"
                   @pointerdown="pointerDownCard($event,viewMyIndex,'battle',cc)">
                <img v-if="cardFaceImage(viewMyIndex,cc)" :src="cardFaceImage(viewMyIndex,cc)" class="card-img" alt="">
              </div>
              <div v-if="stackChildren(root.id).length" class="stack-badge">{{ 1 + stackChildren(root.id).length }}</div>
            </div>
          </div>
        </div>
      </div>

      <div class="row">
        <div class="vstack-sm">
          <div class="zone small" :id="zoneId(viewMyIndex,'deck')">
            <div class="zone-title">山札（{{ players[viewMyIndex].zones.deck.length }}）</div>
            <div class="card-list">
              <div v-if="players[viewMyIndex].zones.deck.length"
                   :key="players[viewMyIndex].zones.deck[0].id"
                   class="card" :class="cardClass(players[viewMyIndex].zones.deck[0])"
                   @pointerdown="pointerDownCard($event,viewMyIndex,'deck',players[viewMyIndex].zones.deck[0])">
                <img v-if="deckTopBackImage(viewMyIndex)" :src="deckTopBackImage(viewMyIndex)" class="card-img" alt="">
                <template v-else>D</template>
              </div>
            </div>
          </div>
          <div class="drop-gate" :id="zoneId(viewMyIndex,'top')">山上</div>
          <div class="drop-gate" :id="zoneId(viewMyIndex,'bottom')">山下</div>
        </div>

        <div class="column" style="flex:1">
          <div class="zone" :id="zoneId(viewMyIndex,'shield')">
            <div class="zone-title">シールド（自分）</div>
            <div class="slot5">
              <div v-for="c in players[viewMyIndex].zones.shield" :key="c.id" class="card" :class="cardClass(c)"
                   @pointerdown="pointerDownCard($event,viewMyIndex,'shield',c)">
                <img v-if="cardFaceImage(viewMyIndex,c)" :src="cardFaceImage(viewMyIndex,c)" class="card-img" alt="">
                <template v-else>S</template>
              </div>
            </div>
          </div>

          <div class="zone" :id="zoneId(viewMyIndex,'mana')">
            <div class="zone-title">マナ（自分）</div>
            <div class="card-list">
              <div v-for="c in players[viewMyIndex].zones.mana" :key="c.id" class="card" :class="cardClass(c)"
                   @pointerdown="pointerDownCard($event,viewMyIndex,'mana',c)">
                <img v-if="cardFaceImage(viewMyIndex,c)" :src="cardFaceImage(viewMyIndex,c)" class="card-img" alt="">
                <template v-else>M</template>
              </div>
            </div>
          </div>

         <div class="zone hand" :id="zoneId(viewMyIndex,'hand')">
            <div class="zone-title">手札（自分）{{ players[viewMyIndex].zones.hand.length }}</div>
            <div class="card-list">
              <div v-for="c in players[viewMyIndex].zones.hand" :key="c.id" class="card" :class="cardClass(c)"
                   @pointerdown="pointerDownCard($event,viewMyIndex,'hand',c)">
                <img v-if="cardFaceImage(viewMyIndex,c)" :src="cardFaceImage(viewMyIndex,c)" class="card-img" alt="">
                <template v-else>H</template>
              </div>
            </div>
          </div>
        </div>

        <div class="zone small" :id="zoneId(viewMyIndex,'graveyard')">
          <div class="zone-title">墓地（{{ players[viewMyIndex].zones.graveyard.length }}）</div>
          <div class="card-list">
            <div v-if="players[viewMyIndex].zones.graveyard.length"
                 :key="players[viewMyIndex].zones.graveyard.at(-1).id"
                 class="card" :class="cardClass(players[viewMyIndex].zones.graveyard.at(-1))"
                 @pointerdown="pointerDownCard($event,viewMyIndex,'graveyard',players[viewMyIndex].zones.graveyard.at(-1))">
              <img v-if="cardFaceImage(viewMyIndex, players[viewMyIndex].zones.graveyard.at(-1))"
                   :src="cardFaceImage(viewMyIndex, players[viewMyIndex].zones.graveyard.at(-1))" class="card-img" alt="">
              <template v-else>G</template>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- ドラッグ中のゴースト -->
    <div v-if="drag.active && drag.moved" class="drag-ghost" :style="dragGhostStyle">
      <img v-if="cardFaceImage(drag.pIndex, drag.card)" :src="cardFaceImage(drag.pIndex, drag.card)" alt="">
    </div>

    <!-- モーダル -->
    <div v-if="modal.show" class="overlay" @click.self="closeModal">
      <div class="modal">
        <h3>{{ modal.title }}</h3>
        <div class="deck-grid">
          <div v-for="c in modal.cards" :key="c.id" class="card">
            <img v-if="modalImageSrc(c)" :src="modalImageSrc(c)" class="card-img" alt="">
          </div>
        </div>
      </div>
    </div>

    <!-- 進行チャット -->
    <div :style="{position:'fixed', right: chatOpen ? '0' : '-320px', top:'var(--bar-h)', bottom:'0',
                  width:'320px', transition:'right .18s ease', background:'#111',
                  borderLeft:'1px solid #444', display:'flex', flexDirection:'column', zIndex:2500 }">
      <div style="padding:8px 10px;border-bottom:1px solid #333;font-size:12px;opacity:.9">進行チャット</div>
      <div id="chat-pane" style="flex:1;overflow:auto;padding:10px">
        <div v-for="m in chatLog" :key="m.id" style="margin:6px 0">
          <div style="font-size:11px;opacity:.6">{{ m.from }} · {{ m.time }}</div>
          <div style="white-space:pre-wrap">{{ m.text }}</div>
        </div>
      </div>
      <div style="display:flex;gap:6px;padding:8px;border-top:1px solid #333">
        <input v-model="chatMsg" @keydown.enter="sendChat" placeholder="メッセージを入力"
               style="flex:1;background:#222;color:#fff;border:1px solid #444;border-radius:6px;padding:6px 8px">
        <button @click="sendChat">送信</button>
      </div>
    </div>
  </div>
    `
  }).mount('#app');

})();
</script>
</body>
</html>