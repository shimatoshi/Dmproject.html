<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>Duel Layout – デッキ読込＋スリーブ＋プレイマット対応</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<style>
  :root{
    --card-h: 56px;
    --card-w: 40px;
    --gap: 6px;
    --font: 12px;
    --bar-h: 44px;
    --small-zone-w-mul: 1.4;
    --gate-w-mul: 1.2; /* ドロップしやすく */
  }
  *, *::before, *::after { box-sizing: border-box; }
  .zone, .drop-gate { min-width: 0; }

  html,body{margin:0;height:100%;background:#1a1a1a;color:#fff;font-family:sans-serif;overflow:hidden}
  #app{height:100vh;display:flex;flex-direction:column}

  .bar{height:var(--bar-h);min-height:var(--bar-h);max-height:var(--bar-h);
       padding:0 var(--gap);display:flex;align-items:center;gap:var(--gap);border-bottom:1px solid #444}
  button,label.btn-like{
    background:#555;color:#fff;border:none;padding:6px 8px;border-radius:6px;font-size:calc(var(--font) * 0.95);cursor:pointer
  }
  button:active,label.btn-like:active{transform:translateY(1px)}
  .spacer{flex:1}

  .field{flex:1;display:flex;flex-direction:column;border-bottom:1px solid #444;
         padding:var(--gap);gap:var(--gap);position:relative;background-size:cover;background-position:center}
  .row{display:flex;gap:var(--gap);min-height:0}

  /* 縦1列の帯配置 */
  .column{display:flex;flex-direction:column;gap:var(--gap);}
  .vstack-sm{display:flex;flex-direction:column;gap:var(--gap);align-items:stretch;}

 .zone{
  flex:1;
  background:rgba(255,255,255,0.08); /* 白を8%だけのせる → 薄い灰色 */
  border:1px solid rgba(255,255,255,0.15); /* 枠も薄く */
  border-radius:10px;
  padding:var(--gap);
  display:flex;
  flex-direction:column;
  transition:border-color .12s ease, box-shadow .12s ease;
}
  .zone.small{flex:none;width:calc(var(--card-w) * var(--small-zone-w-mul))}
  .zone-title{font-size:calc(var(--font) * 0.9);opacity:.8;margin-bottom:calc(var(--gap) * 0.6);line-height:1}

  .card-list{display:flex;flex-wrap:wrap;gap:calc(var(--gap) * 0.6)}
  .slot5{display:grid;grid-template-columns:repeat(5, var(--card-w));gap:calc(var(--gap) * 0.6)}

  .zone.drop-ok, .drop-gate.drop-ok{border-color:#73d2ff; box-shadow:0 0 0 2px #73d2ff55 inset}

  .card{
    position:relative;
    width:var(--card-w); height:var(--card-h);
    border-radius:8px;background:#2a2a2a;color:#111;
    display:flex;align-items:center;justify-content:center;font-weight:bold;user-select:none;
    outline:2px solid transparent;transition:transform .1s ease, outline-color .1s ease;
    font-size:calc(var(--font) * 0.95); overflow:hidden;
  }
  .card.tapped{transform:rotate(90deg)}
  .card.selected{outline-color:#73d2ff}

  .card-img{position:absolute; inset:0; width:100%; height:100%; object-fit:cover}

  .drag-ghost{
    position:fixed; left:0; top:0; width:var(--card-w); height:var(--card-h); pointer-events:none;
    transform:translate(var(--x), var(--y));
    border-radius:8px; background:#222; color:#111; display:flex; align-items:center; justify-content:center;
    opacity:.98; z-index:10000; box-shadow:0 8px 24px rgba(0,0,0,.45);
    font-size:calc(var(--font) * 0.95); overflow:hidden;
  }
  .drag-ghost img{position:absolute; inset:0; width:100%; height:100%; object-fit:cover}

  /* 山上/山下ゲート：幅+高さを少し拡大してドロップしやすく */
.drop-gate{
  flex:none;
  width:calc(var(--card-w) * var(--gate-w-mul));
  background:rgba(255,255,255,0.05); /* さらに薄く */
  border:1px dashed rgba(255,255,255,0.25);
  border-radius:6px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:calc(var(--font)*0.8);
  opacity:0.9; /* 薄い色でも視認性を確保 */
}

  /* モーダル（5×8固定グリッド） */
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,0.8);
           display:flex;justify-content:center;align-items:center;z-index:2000}
  .modal{background:#222;padding:16px;border-radius:8px;max-width:90vw;max-height:90vh;overflow:auto}
  .modal h3{margin:0 0 8px 0;font-size:14px}
  .deck-grid{
    display:grid;
    grid-template-columns:repeat(5, var(--card-w));
    grid-auto-rows:var(--card-h);
    gap:6px;justify-content:center
  }
  input[type="file"]{display:none}
</style>
</head>
<body>
<div id="app"></div>

<script>
const { createApp } = Vue;

const ws = new WebSocket("wss://name-ontario-assign-retro.trycloudflare.com");

createApp({
  data(){
    // 40枚の「空カード」を生成（番号だけ持つ）。imageは後からJSONで割り当て。
    const makeDeck = (prefix) =>
      Array.from({ length: 40 }, (_, i) => ({
        id: `${prefix}-c${i + 1}`, // 既存互換ID（カード固有キーとして使用）
        num: i + 1,                // 1..40 のカード番号
        image: null                // 後から割り当て
      }));

    return {
      players:[
        { name:'相手',
          zones:{ hand:[], mana:[], graveyard:[], shield:[], deck:makeDeck('p0'), battle:[] },
          sleeve:null,  // 裏面（スリーブ）
          mat:null      // フィールド背景（相手側は通常未使用）
        },
        { name:'自分',
          zones:{ hand:[], mana:[], graveyard:[], shield:[], deck:makeDeck('p1'), battle:[] },
          sleeve:null,  // 裏面（スリーブ）
          mat:null      // 自分側プレイマット
        }
      ],
      cardStates:{},             // id -> {tapped, faceDown}
      selected:null,
      lpTimer:null,
      drag:{active:false,pIndex:null,zoneKey:null,card:null,x:0,y:0,startX:0,startY:0,moved:false,dropTarget:null},
      zoneKeys:['hand','mana','graveyard','shield','deck','battle','top','bottom'],
      modal:{show:false,cards:[],title:''}
    }
  },

  mounted(){
    // 初期配り（空カードでも進行できる）
    this.setup(0);
    this.setup(1);

    const resize=()=>this.computeLayout();
    window.addEventListener('resize',resize);
    window.addEventListener('orientationchange',resize);
    this.computeLayout();

    window.addEventListener('pointermove', this.onPointerMove);
    window.addEventListener('pointerup', this.onPointerUp);
  },

  beforeUnmount(){
    window.removeEventListener('pointermove', this.onPointerMove);
    window.removeEventListener('pointerup', this.onPointerUp);
  },

  methods:{
    /* ===== レイアウトスケール ===== */
    computeLayout(){
      const vh = window.innerHeight;
      const vw = window.innerWidth;
      const barH = 44;

      const rows = 6, titlePad = 14;
      const styles = getComputedStyle(document.documentElement);
      const gap = parseFloat(styles.getPropertyValue('--gap')) || 6;
      const smallMul = parseFloat(styles.getPropertyValue('--small-zone-w-mul')) || 1.4;
      const gateMul  = parseFloat(styles.getPropertyValue('--gate-w-mul')) || 1.2;

      const usableH = Math.max(200, vh - barH);
      let hCard = Math.floor((usableH - rows * (titlePad + gap)) / rows);
      hCard = Math.max(34, Math.min(hCard, 86));
      let wCard = Math.floor(hCard * 0.714);

      // 横幅見積（最広段） = [小] + [縦カラム(=シールド5枚幅)] + [小] + [ゲート] + [ゲート]
      const gaps = 4 * gap, safety = 24;
      const neededW = ( (2*smallMul + 2*gateMul + 5) * wCard ) + gaps + safety;

      const scaleW = neededW > vw ? (vw / neededW) : 1;
      wCard = Math.floor(wCard * scaleW);
      hCard = Math.floor(hCard * scaleW);

      document.documentElement.style.setProperty('--card-h', hCard + 'px');
      document.documentElement.style.setProperty('--card-w', wCard + 'px');
    },

    /* ===== デッキJSONを読み込んで割り当て =====
       形式:
       {
         "version": 1,
         "sleeve": "https://.../sleeve.png",
         "mat": "https://.../playmat.png",
         "images": ["https://.../card1.png", ... 最大40]
       }
    */
    onImportDeck(evt, pIndex){
      const file = evt.target.files?.[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = (e)=>{
        try{
          const deckJson = JSON.parse(e.target.result);
          // プレイヤー設定（スリーブ/プレイマット）
          this.players[pIndex].sleeve = deckJson.sleeve || null;
          if(pIndex === 1) { // 自分側だけプレイマット適用
            this.players[pIndex].mat = deckJson.mat || null;
          }

          // デッキを番号順で再生成し、画像を割り当て
          this.players[pIndex].zones = { hand:[], mana:[], graveyard:[], shield:[], deck: this.makeDeckFresh(pIndex), battle:[] };
          this.applyDeckImages(pIndex, deckJson);

          // シャッフルせずに配り直し（番号順 → シールド5/手札5/残り）
          this.setup(pIndex, { shuffle:false });
        }catch(err){
          console.error(err);
          alert('デッキJSONの読み込みに失敗しました');
        }
        evt.target.value = ''; // 同じファイル再読込できるようにクリア
      };
      reader.readAsText(file);
    },

    makeDeckFresh(pIndex){
      // 番号1..40で空カードを再生成
      return Array.from({ length: 40 }, (_, i) => ({
        id: `p${pIndex}-c${i + 1}`,
        num: i + 1,
        image: null
      }));
    },

    applyDeckImages(pIndex, deckJson){
      const imgs = Array.isArray(deckJson?.images) ? deckJson.images : [];
      const deck = this.players[pIndex].zones.deck;
      for(let i=0; i<Math.min(deck.length, imgs.length); i++){
        const url = imgs[i];
        deck[i].image = (typeof url === 'string' && url) ? url : null;
      }
    },

    /* ===== 基本操作 ===== */
    shuffleDeck(p){
      const d=this.players[p].zones.deck;
      for(let i=d.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[d[i],d[j]]=[d[j],d[i]];}
    },
    drawCard(p){
      const P=this.players[p]; if(!P.zones.deck.length) return;
      P.zones.hand.push(P.zones.deck.shift());
    },
    setup(pIndex, opts = { shuffle:true }){
      const P=this.players[pIndex];
      if(opts.shuffle){ this.shuffleDeck(pIndex); }

      // 初期配り
      P.zones.shield = P.zones.deck.slice(0,5);
      P.zones.hand   = P.zones.deck.slice(5,10);
      P.zones.deck   = P.zones.deck.slice(10);

      // シールドは裏面
      for(const c of P.zones.shield){
        const st=this.cardStates[c.id] || {tapped:false,faceDown:false};
        st.faceDown=true; this.cardStates[c.id]=st;
      }
    },

    /* ===== カード状態 ===== */
    isFaceDown(card){ const st=this.cardStates[card.id]; return !!(st && st.faceDown); },
    toggleTap(card){
      const st=this.cardStates[card.id] ||= {tapped:false, faceDown:false};
      st.tapped=!st.tapped; this.$forceUpdate();
    },
    flip(card){
      const st=this.cardStates[card.id] ||= {tapped:false, faceDown:false};
      st.faceDown=!st.faceDown; this.$forceUpdate();
    },
    cardClass(card){
      const st=this.cardStates[card.id];
      return { 'tapped':!!(st&&st.tapped), 'selected': this.selected && this.selected.card.id===card.id };
    },
    cardFaceImage(pIndex, card){
      // 表なら card.image、裏ならプレイヤーの sleeve（なければnull）
      return this.isFaceDown(card) ? (this.players[pIndex].sleeve || null) : (card.image || null);
    },

    /* ===== タッチムーブ ===== */
    pointerDownCard(e,pIndex,zoneKey,card){
      e.preventDefault();

      const isDeck = zoneKey === 'deck'; // デッキは移動専用（誤操作防止）
      if(!isDeck){
        this.lpTimer=setTimeout(()=>{ this.flip(card); this.lpTimer=null; },450); // 長押しで裏表
      }

      // ドラッグ初期化
      this.drag.active=true; this.drag.pIndex=pIndex; this.drag.zoneKey=zoneKey; this.drag.card=card;
      this.drag.startX=e.clientX; this.drag.startY=e.clientY; this.drag.x=e.clientX; this.drag.y=e.clientY;
      this.drag.moved=false; this.drag.dropTarget=null;
      this.selected={pIndex,zoneKey,card};
    },
    onPointerMove(e){
      if(!this.drag.active) return;
      this.drag.x=e.clientX; this.drag.y=e.clientY;
      if(!this.drag.moved){
        const dx=this.drag.x-this.drag.startX, dy=this.drag.y-this.drag.startY;
        if(Math.hypot(dx,dy) > 6){
          this.drag.moved=true;
          if(this.lpTimer){ clearTimeout(this.lpTimer); this.lpTimer=null; }
        }
      }
      if(this.drag.moved){ this.updateDropTarget(e.clientX, e.clientY); }
    },
    onPointerUp(){
      if(!this.drag.active) return;

      // デッキ以外は短押しで回転
      if(this.drag.zoneKey !== 'deck' && this.lpTimer){
        clearTimeout(this.lpTimer); this.lpTimer=null; this.toggleTap(this.drag.card);
      }

      if(this.drag.moved && this.drag.dropTarget){
        const tgt=this.drag.dropTarget;

        // 山上/山下転送（同プレイヤーのみ）
        if(tgt.pIndex===this.drag.pIndex && (tgt.zoneKey==='top' || tgt.zoneKey==='bottom')){
          const from=this.players[this.drag.pIndex].zones[this.drag.zoneKey];
          const idx=from.findIndex(c=>c.id===this.drag.card.id); if(idx>=0) from.splice(idx,1);
          const deck=this.players[tgt.pIndex].zones.deck;
          if(tgt.zoneKey==='top') deck.unshift(this.drag.card); else deck.push(this.drag.card);
        }
        // 通常ゾーン移動（同プレイヤー内）
        else if(tgt.pIndex===this.drag.pIndex && tgt.zoneKey!==this.drag.zoneKey){
          const from=this.players[this.drag.pIndex].zones[this.drag.zoneKey];
          const idx=from.findIndex(c=>c.id===this.drag.card.id); if(idx>=0) from.splice(idx,1);
          this.players[tgt.pIndex].zones[tgt.zoneKey].push(this.drag.card);
        }
      }
      this.clearDrag();
    },
    clearDrag(){
      document.querySelectorAll('.zone.drop-ok,.drop-gate.drop-ok').forEach(el=>el.classList.remove('drop-ok'));
      this.drag={active:false,pIndex:null,zoneKey:null,card:null,x:0,y:0,startX:0,startY:0,moved:false,dropTarget:null};
      this.selected=null;
    },
    updateDropTarget(px,py){
      const pid=this.drag.pIndex; let best=null;
      for(const key of this.zoneKeys){
        const el=document.getElementById(this.zoneId(pid,key)); if(!el) continue;
        const r=el.getBoundingClientRect();
        const inside=(px>=r.left && px<=r.right && py>=r.top && py<=r.bottom);
        el.classList.toggle('drop-ok', inside);
        if(inside) best={pIndex:pid, zoneKey:key};
      }
      this.drag.dropTarget=best;
    },
    zoneId(pIndex, zoneKey){ return `zone-${pIndex}-${zoneKey}`; },

    /* ===== モーダル ===== */
    openModal(cards, title){ this.modal={show:true, cards:[...cards], title}; },
    closeModal(){ this.modal.show=false; }
  },

  template: `
  <div style="height:100%;display:flex;flex-direction:column;">
    <!-- 操作バー -->
    <div class="bar">
      <button @click="setup(0)">相手配り直し</button>
      <button @click="drawCard(0)">相手ドロー</button>
      <button @click="openModal(players[0].zones.deck,'相手の山札（5×8）')">山札表示</button>
      <button @click="openModal(players[0].zones.graveyard,'相手の墓地（5×8）')">墓地表示</button>

      <label class="btn-like">
        相手デッキ読込
        <input type="file" accept="application/json" @change="onImportDeck($event, 0)">
      </label>

      <span class="spacer"></span>

      <button @click="setup(1)">自分配り直し</button>
      <button @click="drawCard(1)">自分ドロー</button>
      <button @click="openModal(players[1].zones.deck,'自分の山札（5×8）')">山札表示</button>
      <button @click="openModal(players[1].zones.graveyard,'自分の墓地（5×8）')">墓地表示</button>

      <label class="btn-like">
        自分デッキ読込
        <input type="file" accept="application/json" @change="onImportDeck($event, 1)">
      </label>
    </div>

    <!-- 相手フィールド（背景は通常未適用） -->
    <section class="field">
      <div class="row">
        <!-- 左：墓地（サムネ1枚＋枚数） -->
        <div class="zone small" :id="zoneId(0,'graveyard')">
          <div class="zone-title">墓地（{{ players[0].zones.graveyard.length }}）</div>
          <div class="card-list">
            <div v-if="players[0].zones.graveyard.length"
                 :key="players[0].zones.graveyard[players[0].zones.graveyard.length-1].id"
                 class="card" :class="cardClass(players[0].zones.graveyard[players[0].zones.graveyard.length-1])"
                 @pointerdown="pointerDownCard($event,0,'graveyard',players[0].zones.graveyard[players[0].zones.graveyard.length-1])">
              <img v-if="cardFaceImage(0, players[0].zones.graveyard[players[0].zones.graveyard.length-1])"
                   :src="cardFaceImage(0, players[0].zones.graveyard[players[0].zones.graveyard.length-1])" class="card-img" alt="">
              <template v-else>G</template>
            </div>
          </div>
        </div>

        <!-- 中央：縦1列（シールド→マナ→手札） -->
        <div class="column" style="flex:1">
          <div class="zone" :id="zoneId(0,'shield')">
            <div class="zone-title">シールド（相手）</div>
            <div class="slot5">
              <div v-for="c in players[0].zones.shield" :key="c.id"
                   class="card" :class="cardClass(c)"
                   @pointerdown="pointerDownCard($event,0,'shield',c)">
                <img v-if="cardFaceImage(0,c)" :src="cardFaceImage(0,c)" class="card-img" alt="">
                <template v-else>S</template>
              </div>
            </div>
          </div>

          <div class="zone" :id="zoneId(0,'mana')">
            <div class="zone-title">マナ（相手）</div>
            <div class="card-list">
              <div v-for="c in players[0].zones.mana" :key="c.id"
                   class="card" :class="cardClass(c)"
                   @pointerdown="pointerDownCard($event,0,'mana',c)">
                <img v-if="cardFaceImage(0,c)" :src="cardFaceImage(0,c)" class="card-img" alt="">
                <template v-else>M</template>
              </div>
            </div>
          </div>

          <div class="zone" :id="zoneId(0,'hand')">
            <div class="zone-title">手札（相手）{{ players[0].zones.hand.length }}</div>
            <div class="card-list">
              <div v-for="c in players[0].zones.hand" :key="c.id"
                   class="card" :class="cardClass(c)"
                   @pointerdown="pointerDownCard($event,0,'hand',c)">
                <img v-if="cardFaceImage(0,c)" :src="cardFaceImage(0,c)" class="card-img" alt="">
                <template v-else>C</template>
              </div>
            </div>
          </div>
        </div>

        <!-- 右：山札（1枚表示・ドラッグ可）＋ 山上/山下ゲート -->
        <div class="vstack-sm">
          <div class="zone small" :id="zoneId(0,'deck')">
            <div class="zone-title">山札（{{ players[0].zones.deck.length }}）</div>
            <div class="card-list">
              <div v-if="players[0].zones.deck.length"
                   :key="players[0].zones.deck[0].id"
                   class="card" :class="cardClass(players[0].zones.deck[0])"
                   @pointerdown="pointerDownCard($event,0,'deck',players[0].zones.deck[0])">
                <img v-if="cardFaceImage(0, players[0].zones.deck[0])" :src="cardFaceImage(0, players[0].zones.deck[0])" class="card-img" alt="">
                <template v-else>D</template>
              </div>
            </div>
          </div>
          <div class="drop-gate" :id="zoneId(0,'top')">山上</div>
          <div class="drop-gate" :id="zoneId(0,'bottom')">山下</div>
        </div>
      </div>

      <!-- バトル（相手） -->
      <div class="row">
        <div class="zone" :id="zoneId(0,'battle')">
          <div class="zone-title">バトル（相手）</div>
          <div class="card-list">
            <div v-for="c in players[0].zones.battle" :key="c.id"
                 class="card" :class="cardClass(c)"
                 @pointerdown="pointerDownCard($event,0,'battle',c)">
              <img v-if="cardFaceImage(0,c)" :src="cardFaceImage(0,c)" class="card-img" alt="">
              <template v-else>B</template>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 自分フィールド（プレイマット適用） -->
    <section class="field"
             :style="{ backgroundImage: players[1].mat ? 'url(' + players[1].mat + ')' : 'none' }">
      <!-- バトル（自分） -->
      <div class="row">
        <div class="zone" :id="zoneId(1,'battle')">
          <div class="zone-title">バトル（自分）</div>
          <div class="card-list">
            <div v-for="c in players[1].zones.battle" :key="c.id"
                 class="card" :class="cardClass(c)"
                 @pointerdown="pointerDownCard($event,1,'battle',c)">
              <img v-if="cardFaceImage(1,c)" :src="cardFaceImage(1,c)" class="card-img" alt="">
              <template v-else>B</template>
            </div>
          </div>
        </div>
      </div>

      <!-- 山札＋ゲート / 縦1列 / 墓地（サムネ） -->
      <div class="row">
        <!-- 左：山札（1枚表示・ドラッグ可）＋ ゲート -->
        <div class="vstack-sm">
          <div class="zone small" :id="zoneId(1,'deck')">
            <div class="zone-title">山札（{{ players[1].zones.deck.length }}）</div>
            <div class="card-list">
              <div v-if="players[1].zones.deck.length"
                   :key="players[1].zones.deck[0].id"
                   class="card" :class="cardClass(players[1].zones.deck[0])"
                   @pointerdown="pointerDownCard($event,1,'deck',players[1].zones.deck[0])">
                <img v-if="cardFaceImage(1, players[1].zones.deck[0])" :src="cardFaceImage(1, players[1].zones.deck[0])" class="card-img" alt="">
                <template v-else>D</template>
              </div>
            </div>
          </div>
          <div class="drop-gate" :id="zoneId(1,'top')">山上</div>
          <div class="drop-gate" :id="zoneId(1,'bottom')">山下</div>
        </div>

        <!-- 中央：縦1列（シールド→マナ→手札） -->
        <div class="column" style="flex:1">
          <div class="zone" :id="zoneId(1,'shield')">
            <div class="zone-title">シールド（自分）</div>
            <div class="slot5">
              <div v-for="c in players[1].zones.shield" :key="c.id"
                   class="card" :class="cardClass(c)"
                   @pointerdown="pointerDownCard($event,1,'shield',c)">
                <img v-if="cardFaceImage(1,c)" :src="cardFaceImage(1,c)" class="card-img" alt="">
                <template v-else>S</template>
              </div>
            </div>
          </div>

          <div class="zone" :id="zoneId(1,'mana')">
            <div class="zone-title">マナ（自分）</div>
            <div class="card-list">
              <div v-for="c in players[1].zones.mana" :key="c.id"
                   class="card" :class="cardClass(c)"
                   @pointerdown="pointerDownCard($event,1,'mana',c)">
                <img v-if="cardFaceImage(1,c)" :src="cardFaceImage(1,c)" class="card-img" alt="">
                <template v-else>M</template>
              </div>
            </div>
          </div>

          <div class="zone" :id="zoneId(1,'hand')">
            <div class="zone-title">手札（自分）{{ players[1].zones.hand.length }}</div>
            <div class="card-list">
              <div v-for="c in players[1].zones.hand" :key="c.id"
                   class="card" :class="cardClass(c)"
                   @pointerdown="pointerDownCard($event,1,'hand',c)">
                <img v-if="cardFaceImage(1,c)" :src="cardFaceImage(1,c)" class="card-img" alt="">
                <template v-else>H</template>
              </div>
            </div>
          </div>
        </div>

        <!-- 右：墓地（サムネ1枚＋枚数） -->
        <div class="zone small" :id="zoneId(1,'graveyard')">
          <div class="zone-title">墓地（{{ players[1].zones.graveyard.length }}）</div>
          <div class="card-list">
            <div v-if="players[1].zones.graveyard.length"
                 :key="players[1].zones.graveyard[players[1].zones.graveyard.length-1].id"
                 class="card" :class="cardClass(players[1].zones.graveyard[players[1].zones.graveyard.length-1])"
                 @pointerdown="pointerDownCard($event,1,'graveyard',players[1].zones.graveyard[players[1].zones.graveyard.length-1])">
              <img v-if="cardFaceImage(1, players[1].zones.graveyard[players[1].zones.graveyard.length-1])"
                   :src="cardFaceImage(1, players[1].zones.graveyard[players[1].zones.graveyard.length-1])" class="card-img" alt="">
              <template v-else>G</template>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- ドラッグ中のゴースト（表裏に応じて画像を表示） -->
    <div v-if="drag.active && drag.moved"
         class="drag-ghost"
         :style="{ '--x': drag.x - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-w'))/2) + 'px',
                   '--y': drag.y - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-h'))/2) + 'px' }">
      <img v-if="cardFaceImage(drag.pIndex, drag.card)" :src="cardFaceImage(drag.pIndex, drag.card)" alt="">
    </div>

    <!-- モーダル（外側タップで閉じる） -->
    <div v-if="modal.show" class="overlay" @click.self="closeModal">
      <div class="modal">
        <h3>{{ modal.title }}</h3>
        <div class="deck-grid">
          <!-- デッキ/墓地とも、現仕様では裏面表示想定（スリーブがあれば使用） -->
          <div v-for="c in modal.cards" :key="c.id" class="card">
            <img :src="(players[1].sleeve || players[0].sleeve) || ''" class="card-img" v-if="(players[1].sleeve || players[0].sleeve)" alt="">
          </div>
        </div>
      </div>
    </div>
  </div>
  `
}).mount('#app');
</script>
</body>
</html>